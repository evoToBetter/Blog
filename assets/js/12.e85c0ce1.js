(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{484:function(r,t,a){r.exports=a.p+"assets/img/java_proxy.4da58879.png"},513:function(r,t,a){"use strict";a.r(t);var e=a(4),n=Object(e.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",[r._v("记录对代理模式的学习，已经区分静态代理和动态代理。")])]),r._v(" "),e("h2",{attrs:{id:"代理模式定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理模式定义"}},[r._v("#")]),r._v(" 代理模式定义")]),r._v(" "),e("p",[r._v("根据"),e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80",target:"_blank",rel:"noopener noreferrer"}},[r._v("GoF"),e("OutboundLink")],1),r._v("的定义, 代理对象是对另外一个对象的代理或占位，用来实现对其的访问控制。")]),r._v(" "),e("h3",{attrs:{id:"代理模式的用途"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理模式的用途"}},[r._v("#")]),r._v(" 代理模式的用途")]),r._v(" "),e("p",[r._v("使用对象作为其他类时，可以使用代理模式。"),e("br"),r._v("\n用于懒加载资源时，可以使用代理模式。"),e("br"),r._v("\n或者可以用于额外的安全控制方面。")]),r._v(" "),e("h3",{attrs:{id:"代理模式的实际应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代理模式的实际应用"}},[r._v("#")]),r._v(" 代理模式的实际应用")]),r._v(" "),e("p",[r._v("1.hibernate中代理来自数据库的资源对象。实现懒加载"),e("br"),r._v("\n2.代理网络对象，实现安全控制。"),e("br"),r._v("\n3.spring框架中实现AOP编程。")]),r._v(" "),e("h2",{attrs:{id:"静态代理与动态代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态代理与动态代理"}},[r._v("#")]),r._v(" 静态代理与动态代理")]),r._v(" "),e("p",[r._v("1.静态代理可以通过使用普通的java类来实现，在编译期就可以确定所有的代理情况。缺点是需要提前编写所有的代理类，把代理关系确定下来，对代码侵入性比较大。其次灵活性不够，还需要维护庞大的代码。"),e("br"),r._v("\n2.动态代理，可以使用字节码工具来实现，比如javassist，cglib等。限制是类不能是final的，这种方法需要通过继承来实现代理。"),e("br"),r._v("\n另外一种方法是通过jdk的proxy。通过接口来实现代理。"),e("br"),r._v(" "),e("img",{attrs:{src:a(484),alt:"JDK proxy vs CGlib proxy"}}),e("br"),r._v("\n在使用jdk的proxy机制过程中，主要是实现一个InvocationHandler和使用Proxy.newProxyInstance()生成proxyObject，包装原有的对象。然后在proxyObject上调用的方法。")]),r._v(" "),e("h3",{attrs:{id:"动态代理实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态代理实现"}},[r._v("#")]),r._v(" 动态代理实现")]),r._v(" "),e("p",[r._v("我们先来了解下java虚拟机的类加载流程，分为五个阶段，加载、验证、准备、解析、初始化。"),e("br"),r._v("\n【java class加载示意图】"),e("br"),r._v("\n其中在加载阶段完成了")]),r._v(" "),e("ol",[e("li",[r._v("对类的读取，通过类的全限定名找到类，获取类的二进制字节流")]),r._v(" "),e("li",[r._v("将字节流代表的静态存储结构转化为方法区运行时数据结构")]),r._v(" "),e("li",[r._v("在内存中生成一个代表这个类的"),e("code",[r._v("java.lang.class")]),r._v("对象，作为方法区这个类各种数据的访问入口。"),e("br"),r._v("\n实现思路："),e("br"),r._v("\n动态生成代理类字节码，然后加载到jvm中。"),e("br"),r._v("\n常用的字节码操作类库："),e("br"),r._v("\njavassist、CGlib、ASM等。\n为了保持代理类与目标对象的一致性，有两种常见的方式：")]),r._v(" "),e("li",[r._v("JDK动态代理，通过实现接口的方式")]),r._v(" "),e("li",[r._v("CGLIB动态代理，通过继承的方式"),e("br"),r._v("\n【示例代码】")])]),r._v(" "),e("p",[r._v("JDK实现代理："),e("br"),r._v("\n优点：解决了静态代理的冗余"),e("br"),r._v("\n缺点：只能基于接口来使用"),e("br"),r._v("\nCGlib实现动态代理："),e("br"),r._v("\n优点：可以针对接口和类实现代理，灵活方便。采用字节码增强技术，性能不错。"),e("br"),r._v("\n缺点：技术实现相对难以理解。")]),r._v(" "),e("h2",{attrs:{id:"参考链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[r._v("#")]),r._v(" 参考链接")]),r._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://howtodoinjava.com/design-patterns/structural/proxy-design-pattern/",target:"_blank",rel:"noopener noreferrer"}},[r._v("proxy design pattern"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://www.runoob.com/design-pattern/proxy-pattern.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("代理模式|菜鸟教程"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/6844903744954433544",target:"_blank",rel:"noopener noreferrer"}},[r._v("Java 动态代理详解"),e("OutboundLink")],1)]),r._v(" "),e("li",[e("a",{attrs:{href:"https://java-source.net/open-source/bytecode-libraries",target:"_blank",rel:"noopener noreferrer"}},[r._v("bytecode libraries"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);