(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{545:function(r,o,e){"use strict";e.r(o);var t=e(4),v=Object(t.a)({},(function(){var r=this,o=r.$createElement,e=r._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"docker-使用过程中的一些小技巧记录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker-使用过程中的一些小技巧记录"}},[r._v("#")]),r._v(" docker 使用过程中的一些小技巧记录")]),r._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#为非root用户开启docker权限"}},[r._v("为非root用户开启docker权限")])]),e("li",[e("a",{attrs:{href:"#删除不需要的容器和镜像"}},[r._v("删除不需要的容器和镜像")])])])]),e("p"),r._v(" "),e("h3",{attrs:{id:"为非root用户开启docker权限"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为非root用户开启docker权限"}},[r._v("#")]),r._v(" 为非root用户开启docker权限")]),r._v(" "),e("p",[r._v("非root用户无法使用docker的原因是，docker守护线程需要读取Unix套接字/var/run/docker.sock，我们只需要为这个文件增加读权限即可。")]),r._v(" "),e("ol",[e("li",[r._v("增加一个docker组"),e("br"),r._v("\nsudo newgrp docer")]),r._v(" "),e("li",[r._v("将文件的组修改为docker组"),e("br"),r._v("\nsudo chgrp docker /var/run/docker.sock")]),r._v(" "),e("li",[r._v("将用户加入到docker组"),e("br"),r._v("\nsudo usermod -aG ${whoami} docker"),e("br"),r._v("\n注意不加a可能会删除已有的group")])]),r._v(" "),e("h3",{attrs:{id:"删除不需要的容器和镜像"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除不需要的容器和镜像"}},[r._v("#")]),r._v(" 删除不需要的容器和镜像")]),r._v(" "),e("p",[r._v("我们在使用docker的过程中，不可避免的会在本地存有很多无用的docker容器和镜像。\n那么我们来介绍下如何快速的删除这些让强迫症很不爽的无用数据。")]),r._v(" "),e("ol",[e("li",[r._v("删除所有已经停止的容器"),e("br"),r._v(" "),e("em",[e("strong",[r._v("这里需要注意的是删除的容器必须已经停止。")])]),e("br"),r._v("\n你需要使用的命令为："),e("strong",[r._v("docker rm $(docker ps -a -q)")]),r._v("\n这里"),e("strong",[r._v("docker ps -a")]),r._v("是列出所有存在的容器，那么-q的作用是只显示容器ID"),e("br"),r._v("\n那么我们把这些输出作为"),e("strong",[r._v("docker rm")]),r._v("的输入就可以删除所有已经停止的容器。"),e("br"),r._v("\n因为"),e("strong",[r._v("docker rm")]),r._v("在删除还在运行的容器的时候，会报错误信息，而不会删除还在运行的容器。所以不用担心删除还在运行的容器。")]),r._v(" "),e("li",[r._v("删除所有名字或者tag为none的镜像"),e("br"),r._v("\n名字或者tag为none的镜像常常产生于多次使用dockerfile打包同一个版本的镜像。"),e("br"),r._v("\n每次打包后，旧版本的镜像不会被删除，而是会成为一个名字和tag为none的镜像。"),e("br"),r._v("\n那么这个时候如何来删除这些无用的镜像呢？"),e("br"),r._v("\n方法很简单，和一种介绍的类似，使用docker命令组合来完成。"),e("br"),r._v("\n你需要使用的命令为："),e("strong",[r._v('docker rmi $(docker images| grep "^<none>" | awk "{print $3}")')]),e("br"),r._v(" "),e("strong",[r._v("docker rmi")]),r._v("为删除docker镜像的命令。"),e("br"),r._v(" "),e("strong",[r._v("docker images")]),r._v("则是用来查询docker镜像的，然后使用grep命令来过滤，得到所有带有<none>的镜像。"),e("br"),r._v("\n每条记录的第三行为镜像ID，那么我们使用awk来取到它。"),e("br"),r._v("\n这样就可以使用"),e("strong",[r._v("docker rmi")]),r._v("删除它了。")])]),r._v(" "),e("p",[r._v("大家看到了这些小技巧，大部分是docker命令与shell命令结合产生的效果，我们可以活学活用，使用shell来组合docker命令，完成更加复杂的任务。")]),r._v(" "),e("p",[r._v("参考链接："),e("br"),r._v(" "),e("a",{attrs:{href:"https://jimhoskins.com/2013/07/27/remove-untagged-docker-images.html",target:"_blank",rel:"noopener noreferrer"}},[r._v("1.remove untagged dockerimages"),e("OutboundLink")],1)])])}),[],!1,null,null,null);o.default=v.exports}}]);