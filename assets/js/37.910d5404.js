(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{525:function(e,t,a){"use strict";a.r(t);var r=a(4),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",[e._v("深入了解java序列化机制")])]),e._v(" "),a("h2",{attrs:{id:"简单开胃菜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单开胃菜"}},[e._v("#")]),e._v(" 简单开胃菜")]),e._v(" "),a("ol",[a("li",[e._v("java只序列化实现了"),a("code",[e._v("Serializable")]),e._v("或者"),a("code",[e._v("Externalizable")]),e._v("接口的对象, 成员不是基本对象的，其也要实现这些接口，否则会出现"),a("code",[e._v("NotSerializableException")]),e._v("。")]),e._v(" "),a("li",[e._v("不需要序列化的属性可以使用"),a("code",[e._v("transient")]),e._v("修饰。")]),e._v(" "),a("li",[e._v("序列化和反序列化的顺序是一致的。")]),e._v(" "),a("li",[e._v("java进行序列化的类最好带有"),a("code",[e._v("serialVersionUID")]),e._v("作为标识，防止版本号不一致导致的问题。")])]),e._v(" "),a("h2",{attrs:{id:"深入了解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入了解"}},[e._v("#")]),e._v(" 深入了解")]),e._v(" "),a("p",[e._v("在测试前，我们先来搭建一个简单的序列化测试脚手架：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('private static void serializeObject(BiConsumer<ObjectOutputStream,ObjectInputStream> biConsumer) throws IOException {\n        ObjectOutputStream oos=null;\n        ObjectInputStream ois=null;\n\n        try{\n            oos=new ObjectOutputStream(new FileOutputStream(RECORD_FILE_PATH));\n            ois=new ObjectInputStream(new FileInputStream(RECORD_FILE_PATH));\n            biConsumer.accept(oos,ois);\n        }catch(Exception e){\n            logger.error("Can not serial object",e);\n            throw e;\n        }finally{\n            if(oos!=null){\n                oos.close();\n            }\n            if(ois!=null){\n                ois.close();\n            }\n        }\n    }\n')])])]),a("p",[e._v("每次我们只需要把我们的测试逻辑填充进来就可以了。")]),e._v(" "),a("ol",[a("li",[e._v("java针对一个对象不会序列化多次"),a("br"),e._v("\n那么他内部机制是如何的呢？")])]),e._v(" "),a("ol",[a("li",[e._v("java的序列化算法所有保存到磁盘的对象都有一个序列化编号")]),e._v(" "),a("li",[e._v("当需要序列化一个对象时，会先检查这个对象是否已经序列化过了，如果没有序列化过，就将这个对象序列化为字节输出；如果序列化过了，则直接输出编号。"),a("br"),e._v("\n测试代码：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('    @Test\n    public void testModifyObject() throws IOException {\n        UserSource user1 = new UserSource("s1", 10);\n        serializeObject((oos, ois) -> {\n            try {\n                oos.writeObject(user1);\n                user1.setAge(20);\n                oos.flush();\n                UserSource record1 = (UserSource) ois.readObject();\n                Assert.assertEquals(record1.getName(), "s1");\n                Assert.assertEquals(record1.getAge(), 10);\n            } catch (Exception e) {\n                logger.error("serialize fail", e);\n            }\n        });\n    }\n')])])]),a("p",[e._v("可以看到反序列化出来的内容还是保持了原有对象内容，而不是修改后的内容。\n2. 可以使用writeReplace方法来替换目标序列化对象。使用readResolve方法替换反序列化出来的对象。这两个方法需要写在数据类里。"),a("br"),e._v("\n其中单例类需要重写readResolve方法，以免破坏单例原则。\n示例代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    private Object writeReplace(){\n        List<Object> list= new ArrayList<>();\n        list.add(this.name);\n        return list;\n    }\n")])])]),a("p",[e._v("那么序列化后的对象就是一个list")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('    private Object readResolve(){\n        return new UserSourceReadResolve("baby",30);\n    }\n')])])]),a("p",[e._v("那么反序列化出来就是这个对象。\n3. 可以强制自定义序列化，使用"),a("code",[e._v("Externalizable")]),e._v("接口，实现"),a("code",[e._v("writeExternal")]),e._v("和"),a("code",[e._v("readExternal")]),e._v("方法。"),a("br"),e._v("\n注意这两个方法是强制需要实现的，其次是必须提供public的无参数构造器，供反序列化的时候反射创建对象用。"),a("br"),e._v("\n4. 静态变量不会被序列化保存，因为他属于类而不属于对象。"),a("br"),e._v("\n5. 关于父类的序列化，如果父类也实现了序列化接口，那么父类的对象也会被序列化，而如果没有实现序列化接口，则会需要一个默认的无参数构造器，父对象的属性中均为空。"),a("br"),e._v("\n6. 在序列化过程中，虚拟机会试图调用对象类的"),a("code",[e._v("writeObject")]),e._v("和"),a("code",[e._v("readObject")]),e._v("方法。用户可以自定义这两个方法来动态改变序列化的数值。若实现了这两个方法，那么其会覆盖默认的行为，需要把所有序列化操作都自己来实现。")]),e._v(" "),a("h2",{attrs:{id:"测试代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#测试代码"}},[e._v("#")]),e._v(" 测试代码")]),e._v(" "),a("p",[e._v("测试代码详情可以参见"),a("a",{attrs:{href:"https://github.com/evoToBetter/java_practice/blob/master/src/test/evotobetter/serializable/SerialTest.java",target:"_blank",rel:"noopener noreferrer"}},[e._v("SerialTest"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"参考链接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[e._v("#")]),e._v(" 参考链接")]),e._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://www.oracle.com/technical-resources/articles/java/serializationapi.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Discover the secrets of the Java Serialization API"),a("OutboundLink")],1)]),e._v(" "),a("li")])])}),[],!1,null,null,null);t.default=s.exports}}]);